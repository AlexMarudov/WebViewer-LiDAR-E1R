<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LiDAR E1R Online Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <!-- Панель управления -->
    <div id="controls" style="
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        color: white;
        font-family: monospace;
        border-radius: 5px;
        z-index: 100;
    ">
        <button id="btnSave">Сохранить PCD</button>
        <button id="btnBrowse">Просмотр PCD</button>
        <div id="browsePanel" style="display:none; margin-top:10px; min-width:250px;">
            <select id="pcdList" style="width:100%; margin-bottom:8px;"></select>
            <div style="display:flex; gap:6px; margin-bottom:8px; font-size:13px;">
                <label>eps: <input type="number" id="eps" value="0.5" step="0.1" min="0.1" style="width:60px;"></label>
                <label>min: <input type="number" id="minPts" value="10" min="1" style="width:50px;"></label>
            </div>
            <button id="btnCluster" style="width:100%; margin-bottom:6px;">Применить кластеризацию</button>
            <button id="btnBack" style="width:100%;">← Вернуться к онлайн</button>
        </div>
    </div>

    <!-- Информация на экране -->
    <div id="hud" style="
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        font-size: 14px;
        text-shadow: 1px 1px 2px black;
        pointer-events: none;
    "></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 50);
        camera.position.set(-5, 2, 0);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0a);
        document.body.appendChild(renderer.domElement);

        const pointGeometry = new THREE.BufferGeometry();
        const pointMaterial = new THREE.PointsMaterial({
            size: 0.03,
            sizeAttenuation: true,
            transparent: true,
            alphaTest: 0.5,
            vertexColors: false
        });
        const pointCloud = new THREE.Points(pointGeometry, pointMaterial);
        scene.add(pointCloud);

        // Управление камерой
        let isDragging = false;
        let isPanning = false;
        let previousMousePosition = { x: 0, y: 0 };
        let target = new THREE.Vector3(0, 0, 0);

        function onMouseDown(e) {
            isPanning = e.button === 2 || (e.button === 0 && e.shiftKey);
            isDragging = !isPanning;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (!isDragging && !isPanning) return;
            const dx = e.clientX - previousMousePosition.x;
            const dy = e.clientY - previousMousePosition.y;

            if (isDragging) {
                const rotSpeed = 0.01;
                const quat = new THREE.Quaternion()
                    .setFromAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed)
                    .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), dy * rotSpeed));
                camera.position.sub(target).applyQuaternion(quat).add(target);
                camera.lookAt(target);
            } else if (isPanning) {
                const panSpeed = 0.05;
                const panX = dx * panSpeed;
                const panY = dy * panSpeed;
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up).normalize();
                up.copy(camera.up).multiplyScalar(panY);
                right.multiplyScalar(panX);
                target.add(right).add(up);
                camera.position.add(right).add(up);
            }

            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        renderer.domElement.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', () => { isDragging = false; isPanning = false; });
        window.addEventListener('mouseleave', () => { isDragging = false; isPanning = false; });
        renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.1;
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.multiplyScalar(e.deltaY * zoomSpeed * 0.01);
            camera.position.add(dir);
            target.add(dir);
        });

        // === Режимы и состояние ===
        let mode = 'online';
        let currentPcdFilename = null;
        let clusterBoxes = [];
        let pointCount = 0;
        let temp = 25.0;
        let syncMode = "Unknown";
        let fps = 0;
        let lastUpdateTime = 0;

        // === Кнопки ===
        document.getElementById('btnSave').addEventListener('click', async () => {
            const res = await fetch('/save_pcd', { method: 'POST' });
            const data = await res.json();
            if (data.success) alert('Сохранено: ' + data.filename);
            else alert('Ошибка: ' + (data.error || 'неизвестно'));
        });

        document.getElementById('btnBrowse').addEventListener('click', async () => {
            mode = 'browse';
            document.getElementById('browsePanel').style.display = 'block';
            loadPcdList();
        });

        document.getElementById('btnBack').addEventListener('click', () => {
            mode = 'online';
            document.getElementById('browsePanel').style.display = 'none';
            clusterBoxes.forEach(box => scene.remove(box));
            clusterBoxes = [];
            pointMaterial.vertexColors = false;
            pointMaterial.color.set(0x00ffcc);
        });

        async function loadPcdList() {
            const res = await fetch('/list_pcds');
            const data = await res.json();
            const sel = document.getElementById('pcdList');
            sel.innerHTML = '';
            data.files.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f;
                opt.textContent = f;
                sel.appendChild(opt);
            });
            if (data.files.length > 0) {
                loadSelectedPcd();
            }
        }

        document.getElementById('pcdList').addEventListener('change', loadSelectedPcd);

        async function loadSelectedPcd() {
            const filename = document.getElementById('pcdList').value;
            if (!filename) return;
            currentPcdFilename = filename;
            const res = await fetch(`/load_pcd/${filename}`);
            const data = await res.json();
            displayPoints(data.points, data.count);
            clusterBoxes.forEach(box => scene.remove(box));
            clusterBoxes = [];
            pointMaterial.vertexColors = false;
            pointMaterial.color.set(0x00ffcc);
        }

        function displayPoints(rawPoints, count) {
            const transformed = new Float32Array(rawPoints.length);
            for (let i = 0; i < rawPoints.length; i += 3) {
                const x = rawPoints[i];
                const y = rawPoints[i + 1];
                const z = rawPoints[i + 2];
                transformed[i]     = x;
                transformed[i + 1] = z;
                transformed[i + 2] = -y;
            }
            pointGeometry.setAttribute('position', new THREE.BufferAttribute(transformed, 3));
            pointGeometry.attributes.position.needsUpdate = true;
            pointCount = count;
        }

        document.getElementById('btnCluster').addEventListener('click', async () => {
            const filename = currentPcdFilename;
            if (!filename) return;
            const eps = parseFloat(document.getElementById('eps').value);
            const minPts = parseInt(document.getElementById('minPts').value);

            const res = await fetch('/cluster_pcd', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename, eps, min_points: minPts })
            });
            const data = await res.json();

            // Обновляем точки с цветами
            const pos = new Float32Array(data.points.length);
            const col = new Float32Array(data.colors.length);
            for (let i = 0; i < data.points.length; i += 3) {
                const x = data.points[i];     // LiDAR X
                const y = data.points[i + 1]; // LiDAR Y
                const z = data.points[i + 2]; // LiDAR Z

                // Трансформация LiDAR → Three.js (как в displayPoints и онлайн-режиме)
                pos[i]     = x;      // X → X
                pos[i + 1] = z;      // Z → Y
                pos[i + 2] = -y;     // Y → -Z

                // Цвета — в том же порядке
                col[i]     = data.colors[i];
                col[i + 1] = data.colors[i + 1];
                col[i + 2] = data.colors[i + 2];
            }
            pointGeometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            pointGeometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
            pointMaterial.vertexColors = true;
            pointMaterial.color.set(0xffffff);

            // Удаляем старые боксы
            clusterBoxes.forEach(box => scene.remove(box));
            clusterBoxes = [];

            // Добавляем новые AABB-боксы
            // Добавляем новые AABB-боксы (с правильной трансформацией в Three.js)
            data.boxes.forEach(box => {
                const dx = box.max[0] - box.min[0];
                const dy = box.max[1] - box.min[1];
                const dz = box.max[2] - box.min[2];

                // Размеры в Three.js: X=dx, Y=dz (высота), Z=dy (глубина)
                const size = [dx, dz, dy];

                const cx = (box.min[0] + box.max[0]) / 2;
                const cy = (box.min[1] + box.max[1]) / 2;
                const cz = (box.min[2] + box.max[2]) / 2;

                // Центр в Three.js
                const pos_x = cx;
                const pos_y = cz;      // Z_lidar → Y
                const pos_z = -cy;     // Y_lidar → -Z

                const geometry = new THREE.BoxGeometry(size[0], size[1], size[2]);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(...box.color),
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos_x, pos_y, pos_z);
                scene.add(mesh);
                clusterBoxes.push(mesh);
            });
        });

        // === WebSocket ===
        const socket = io();
        socket.on('connect', () => {
            setInterval(() => {
                if (mode === 'online') {
                    socket.emit('request_pointcloud');
                }
            }, 100);
        });

        socket.on('pointcloud_update', (data) => {
            if (mode !== 'online') return;

            const rawPoints = new Float32Array(data.points);
            pointCount = data.count;

            const transformed = new Float32Array(rawPoints.length);
            for (let i = 0; i < rawPoints.length; i += 3) {
                const x = rawPoints[i];
                const y = rawPoints[i + 1];
                const z = rawPoints[i + 2];
                transformed[i]     = x;
                transformed[i + 1] = z;
                transformed[i + 2] = -y;
            }

            pointGeometry.setAttribute('position', new THREE.BufferAttribute(transformed, 3));
            pointGeometry.attributes.position.needsUpdate = true;
            if (!pointMaterial.vertexColors) {
                pointMaterial.color.set(0x00ffcc);
            }

            temp = data.temperature;
            syncMode = data.sync_mode || "Unknown";

            const now = performance.now();
            if (lastUpdateTime) fps = Math.round(1000 / (now - lastUpdateTime));
            lastUpdateTime = now;
        });

        // === Анимация и HUD ===
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);

            document.getElementById('hud').innerHTML = `
                <div>Cam: [${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}]</div>
                <div>Target: [${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)}]</div>
                <div>Points: ${pointCount} | FPS: ${fps} | Temp: ${temp.toFixed(1)}°C | Sync: ${syncMode}</div>
            `;
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>